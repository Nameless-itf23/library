## 前処理

## 包除原理

- 計算したn次元累積和を使う時など

## 累積和

- n次元に拡張可能
- 例えば2次元の場合は、基本は横に累積和取ったあと縦に累積和

## いもす法

- 差分のみの記録＋累積和
- n次元に拡張可能
- ![イメージ](https://imoz.jp/data/imos_method/simple_figure1.png)
- [詳細](https://imoz.jp/algorithms/imos_method.html)

## パリティ

- どう頑張っても そうできない的な(？)

## 繰り返し二乗法

- (a ** b) % m は pow(a,b,m) で計算できる O(log b)

## 貪欲法

- 一見複雑そうな問題でも、貪欲法によって実は答えが一意に定まる場合がある
-上界や下界を考えると、それがそのまま答えになる場合がある

## 二分探索

- bisect_leftまたはbosect_rightで値のindexを検索できる O(log n)
- [めぐる式](https://qiita.com/drken/items/97e37dd6143e33a64c8c)
- 答えで二分探索
    - 「最小値の最大化問題」など

## 木

- 木とは、「連結」で「閉路のない」グラフのこと
- n個の点からなるグラフTについて次は同値
    - Tは木である
    - Tに閉路はなく、n−1本の辺を持つ
    - Tは連結で、n−1本の辺を持つ
    - Tの任意の2点を結ぶ道がちょうど1つある
        - この単純パスの長さの最大値を「木の直径」と呼ぶ
    - Tに閉路はないが、新しい辺をつけ加えると閉路が必ず1つできる
- 木は必ず二部グラフ

### 木の直径を求めるアルゴリズム

- 任意の頂点から各頂点までの最短距離を求める
- 最も最短距離が大きかった頂点をuとして、uからの最短距離を求める。そのときに出現した最短距離の最大値が木の直径
- 計算量は O(N)
- 理由: 木の直径のひとつの両端A,Bとするとき任意のCからの最遠点はA,Bどちらか。よって任意のCから最遠点2回の計算で直径が手に入る
- [maspyさんによる解説](https://twitter.com/maspy_stars/status/1377819629922361344)

## 二部グラフ

- 辺で直接結ばれた点同士が互いに違う色となるように、頂点を2色で塗ることができるグラフ
    - ※ただしこの2色で塗り分けられた頂点の数が等しいとは限らない！例: 1-2, 2-3, 3-4, 2-4 が連結なグラフ
- 奇数長の閉路を含まない
- マッチングが多項式時間で計算できる
- 「最大独立集合」←未検索だがのちに必要になった時用のメモ

## 有向非巡回グラフ(DAG)

- 閉路のない有向グラフ
- グラフGがDAGである⇔Gはトポロジカルソートできる

## トポロジカルソート

- bfsでの実装とdfsでの実装がある
- 有向グラフの閉路の検出(DAGかどうかの検出)ができる
- [参考](https://algo-logic.info/topological-sort/)

## マッチング

- グラフ上から、「どの2辺も両端の頂点を共有しない」という条件で選んだ辺集合を、マッチングと呼ぶ
- 二部グラフでは効率的に解ける
- 極大マッチング
    - もうこれ以上辺を追加で選べない状態
- 最大マッチング
    - 極大マッチングのうち、辺の本数が最大のもの
- 完全マッチング
    - 全頂点が、マッチングの辺のいずれかの端点になっているもの
    - 必ず存在するとは限らない
    - 必然的に最大マッチング
- [参考](https://ikatakos.com/pot/programming_algorithm/graph_theory/bipartite_matching)

## 最短経路問題

- [参考](https://qiita.com/ageprocpp/items/cdf67e828e1b09316f6e)

### 単一始点最短経路問題

- 始点が固定されたとき、そこから他の各頂点への最短距離を求める問題
    - bfs、 01-bfs、 ダイクストラ法、ベルマン・フォード法、dfsなど

### 全頂点対最短経路問題
- 任意の2頂点の対に対して最短経路を求める問題
    - ワーシャル・フロイド法、全頂点に対するダイクストラ法など
    - (未検索だがのちに必要になった時用のメモ)
        - グラフが木であれば「LCA」というものを使った方法を使えば前計算をO(V)、クエリごとにO(logV)で解けるらしい？
        - [参考](https://qiita.com/ageprocpp/items/cdf67e828e1b09316f6e)

## bfs

- deque (新しい頂点を随時右に追加)
- 計算量は O(V+E)

### 01-bfs

- 辺の移動のコストが0か1の場合
- deque (新しい頂点を右にも左にも追加)
    - 辺の移動のコストが0なら左に、コストが1なら右に追加
- 計算量は O(V+E)
- [参考](https://betrue12.hateblo.jp/entry/2018/12/08/000020)

## ダイクストラ法

- 辺の移動コストが非負の場合
- heapq
- 計算量は O(V+Elog(V))
- bfsも01-bfsもダイクストラ法も、queue(heapq)内の頂点を移動コスト順に並べている！

## 拡張bfs、拡張ダイクストラ

- 同じ頂点にいるときでも複数の状態が考えられるときなど
- 状態の分だけ頂点倍加を行う(増やし過ぎるとTLEになるので注意)
- [参考](https://qiita.com/Kept1994/items/19a9ebc3fbfe8fc659ee)


## ベルマン・フォード法

- (未検索だがのちに必要になった時用のメモ)
- 負のコストの辺がある場合
- 計算量は O(VE)

## ワーシャル・フロイド法
- (未検索だがのちに必要になった時用のメモ)
- 計算量は O(V^3)

## dfs
- 完全グラフでは、計算量は O((n-1)!) (ありうる全ての経路を探索することになる)
- 木では、計算量は O(n)
- 木ではないグラフでdfsするときは大抵制約が緩い(小さい値)

## バックトラック

- 全探索の一種
- 検索ルートの途中で条件に一致するものが無いことが分かった場合に、一つ前に戻り別ルートでの検索を行う手法
- (疑問)dfsと何が違うの...？

## dp

- (直前の)状態からの遷移によって次の状態が決まるときなど
- 状態をdpで持つ
- 必ずしも直前と直後の状態変化のみで考えるとは限らない
- この状態に至るまでにどの状態からの遷移が考えられるか(複数ある場合もある)
- 数列のlからrまでの連続部分列を考える問題など(愚直にやるとO(n^2))

### bitDP

- 集合を扱うdp

## 尺取り法

- 単調性が利用できる場合
- 数列のlからrまでの連続部分列を考える問題など(愚直にやるとO(n^2))
    - この場合の単調性はl_nに対しr_nが答えになるとき、l_(n+1)に対しr_(n+1) >= r_(n)が成立する場合など

## 因数分解

- 組み合わせ系の問題など
- 答えを立式して因数分解すると簡単に求められることがある
- 答えが繰り返し規則的に足し算と掛け算をしている場合は疑う

## 素因数分解

- O(√n)

## エラトステネスのふるい

## UnionFind

- 与えられたグラフが複数のグラフに分かれていて、それを集合によって管理した方が良さそうなときなど
- グラフの連結判定をほぼ O(1) で行える

## マンハッタン距離

- xとyを独立に考える
- 動かしたときの変化量に注目する
- L(list)からpまでのマンハッタン距離の総和が最小になるようなpはLの中央値
    - 理由: pの右側の点の数より左側の数の方が多い場合はpを左に動かすと総和が減る(逆も然り)
    - 左右で均衡がとれるのはpがLの中央値の時
    - [参考](https://twitter.com/e869120/status/1406020809492090882)

## 鳩の巣原理

## ランレングス圧縮

## 色々なデータ構造

### set

### defaultdict

### deque

- 両端以外のindexにアクセスするのは遅い、O(n)

### heapq

## forを減らす手段集

- 前処理+set(複数の要素がいくつかのグループに分けられる場合など(剰余類のイメージ))

## その他テクニック

- (特に簡単な問題や配列を扱う問題)なるべく綺麗な実装を考えよう
- 汚い実装しか思いつかなかったら、いったん別のアプローチで書けないか考えよう(そうしないとここで大幅なロスになる！！)
- まずは小さいケースを考える
- 立式する or 書いてみる
- 立式してシグマを入れ替える(タテをヨコで見る)
- 差分に注目する
- 変な制約に着目する
    - 状態数が少ない変量を決め打ちして全探索
- 小数が出てくる問題はできるだけ整数で処理して誤差をなくす
- 約数の数は超少ない
    - 10**6以下では720720で最大(240個)
    - 10**9以下では735134400で最大(1344個)
    - 10**12以下では963761198400で最大(6720個)
    - 10**18以下では897612484786617600で最大(103680個)
- コーナーケースには気をつけよう！
- 10**9+7などでの割り忘れに注意！(多倍長だから忘れやすい)
- forの数だとTLEしそうでも定数倍の部分でACになることがある
- 複数回操作を行う問題の場合
    - 操作を逆から考える
    - 現時点での答えはどうなるか・操作の前後での答えの差分に注目する
    - 完成形を想像する
    - 1つの状態に至るまでの過程で場合分けする
    - 操作順序によらない場合、わかりやすいところ(例えば端)から考える
    - 周期性があるかを考える(操作の回数が10**6を超えるときなど)
- グラフに置き換える
- 同じ意味のものをまとめて考える
- 上界と下界を見積もる(上界がそのまま答えになる場合もある)
- 問題文の条件をちゃんと全部使えてるか確認する(使えてない条件がヒントになることがある)
- 円環は列にして2倍にする
- 余事象を考える
- 数列のlからrまでの連続部分列を考える問題(愚直にやるとO(n^2))
    - dp
    - 尺取り法
- インタラクティブな問題では、REはWAに強制される