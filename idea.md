## 前処理

## 包除原理

- 計算したn次元累積和を使う時など

## 累積和

- n次元に拡張可能
- 例えば2次元の場合は、基本は横に累積和取ったあと縦に累積和

## いもす法

- 差分のみの記録＋累積和
- n次元に拡張可能
- ![イメージ](https://imoz.jp/data/imos_method/simple_figure1.png)
- [詳細](https://imoz.jp/algorithms/imos_method.html)

## パリティ

- どう頑張っても そうできない的な(？)

## 繰り返し二乗法

- (a ** b) % m は pow(a,b,m) で計算できる O(log b)

## 貪欲法

- 一見複雑そうな問題でも、貪欲法によって実は答えが一意に定まる場合がある
-上界や下界を考えると、それがそのまま答えになる場合がある

## 二分探索

- bisect_leftまたはbosect_rightで値のindexを検索できる O(log n)
- [めぐる式](https://qiita.com/drken/items/97e37dd6143e33a64c8c)
- 答えで二分探索
    - 「最小値の最大化問題」など

## 木

- 木とは、「連結」で「閉路のない」グラフのこと
- n個の点からなるグラフTについて次は同値
    - Tは木である
    - Tに閉路はなく、n−1本の辺を持つ
    - Tは連結で、n−1本の辺を持つ
    - Tの任意の2点を結ぶ道がちょうど1つある
        - この単純パスの長さの最大値を「木の直径」と呼ぶ
    - Tに閉路はないが、新しい辺をつけ加えると閉路が必ず1つできる

### 木の直径を求めるアルゴリズム

- 任意の頂点から各頂点までの最短距離を求める
- 最も最短距離が大きかった頂点をuとして、uからの最短距離を求める。そのときに出現した最短距離の最大値が木の直径
- 計算量は O(N)
- 理由: 木の直径のひとつの両端A,Bとするとき任意のCからの最遠点はA,Bどちらか。よって任意のCから最遠点2回の計算で直径が手に入る
- [maspyさんによる解説](https://twitter.com/maspy_stars/status/1377819629922361344)

## bfs

## dfs
- 計算量は O((n-1)!)

## dp

- (直前の)状態からの遷移によって次の状態が決まるときなど
- 状態をdpで持つ

## 因数分解

- 組み合わせ系の問題など
- 答えを立式して因数分解すると簡単に求められることがある
- 答えが繰り返し規則的に足し算と掛け算をしている場合は疑う

## 素因数分解

- O(√n)

## UnionFind

- 与えられたグラフが複数のグラフに分かれていて、それを集合によって管理した方が良さそうなときなど

## ランレングス圧縮

## 色々なデータ構造

### set

### defaultdict

### deque

- 両端以外のindexにアクセスするのは遅い、O(n)

### heapq

## forを減らす手段集

- 前処理+set(複数の要素がいくつかのグループに分けられる場合など(剰余類のイメージ))

## その他テクニック

- まずは小さいケースを考える
- 立式する or 書いてみる
- 立式してシグマを入れ替える(タテをヨコで見る)
- 差分に注目する
- 小数が出てくる問題はできるだけ整数で処理して誤差をなくす
- コーナーケースには気をつけよう！
- 10**9+7などでの割り忘れに注意！(多倍長だから忘れやすい)
- forの数だとTLEしそうでも定数倍の部分でACになることがある
- 複数回操作を行う問題の場合
    - 操作を逆から考える
    - 現時点での答えはどうなるか・操作の前後での答えの差分に注目する
    - 完成形を想像する
    - 1つの状態に至るまでの過程で場合分けする
    - 操作順序によらない場合、わかりやすいところ(例えば端)から考える
- グラフに置き換える
- 同じ意味のものをまとめて考える
- 上界と下界を見積もる(上界がそのまま答えになる場合もある)
- 問題文の条件をちゃんと全部使えてるか確認する(使えてない条件がヒントになることがある)
- 円環は列にして2倍にする
-　余事象を考える